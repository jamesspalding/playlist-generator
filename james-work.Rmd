---
title: "James File"
author: "James Spalding"
date: "2023-11-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
attach(songs)
```

```{r}
#Step 1: clean data

songs = read.csv("spotify_songs.csv") 
songs = distinct(songs, track_id, .keep_all = T) %>% #removing duplicate songs
  select(c(-track_album_id, -track_album_name, #removing album info
           -playlist_name, -playlist_id, #removing playlist info
           -mode, -duration_ms)) #removing unnecessary info
```

```{r}
#plotting regression
factorAvg = rowMeans(songs[8:17])

lm(track_popularity~as.factor(playlist_genre)+instrumentalness+energy+loudness+danceability+acousticness+liveness+tempo+valence)

ggplot(songs, aes(instrumentalness, track_popularity, color = playlist_genre))+
  geom_point()+
  geom_abline()


```

```{r}
songs2 = songs %>%
  select(track_popularity, 8:17) #using only numeric values

songPC = princomp(songs2, cor = T)
summary(songPC, loadings = T) #only 33.66% explained with 2 comps

library(ggfortify)
autoplot(songPC, loadings=T, loadings.label=T, data = songs2) #looks kind of nice?
```





-------------------------------------





# Playlist Generation

```{r}
#Idea: Since popularity is likeness of the masses, we can use regression line to predict most "popular" song that relates to the original song.

playlist.create = function(givenID, n = 1){ #Takes track_id as string and desired playlist length int n
  #initialize song selection
  givenSong = songs %>%
    filter(track_id == givenID) #selects all data on selected song
  
  #Error handling
  if((n%%1==0) == F){ #Checks that n is an integer
    return("Please enter valid playlist length.")
  }
  if(nrow(givenSong) == 0){ #check that song is on list
    return("Song not found.")
  }
  
  #Picking best song
  #Idea: using the regression model, we can identify the most important factors. We can search using a series of t-tests to narrow down to the "best" song
  
#-----X1: Genre-----#  
  genreDF = songs %>% #genre is the most important factor, so it will go first.
    filter(playlist_genre == givenSong$playlist_genre)
  
print(nrow(genreDF))
    
#-----X2: Instrumentalness-----#
  similarity = data.frame(sim = numeric(nrow(genreDF)))
  for(i in 1:nrow(similarity)){
    similarity[i,] = abs(givenSong[1,14] - genreDF[i,14])
  }
  
  tempDF = cbind(genreDF, similarity) %>% #selecting songs with bottom 50% closest
    filter(sim < quantile(similarity[,1])[3]) %>%
    select(-sim) #removing temp sim
  
print(nrow(tempDF))

#-----X3-X9: Everything Else-----#  
  variableIndex = c(9, 11, 8, 13, 15, 17, 16) #energy, loudness, danceability, acousticness, liveness, tempo, valence
  for(x in variableIndex){ #loop through remaining variables
    similarity = data.frame(sim = numeric(nrow(tempDF))) 
    for(i in 1:nrow(similarity)){
      similarity[i,] = abs(givenSong[1,x] - tempDF[i,x])
    }
    
    tempDF = cbind(tempDF, similarity) %>% #selecting songs with bottom 50% closest
      filter(sim < quantile(similarity[,1])[3]) %>%
      select(-sim) #removing temp sim
  }
  
#-----Final Selection-----#   
  print(tempDF[sample(1:nrow(tempDF), 1),]) #using a random number in order to obtain unique playlists.

}


playlist.create("3YBZIN3rekqsKxbJc9FZko", 5)
```


```{r}
  pvals = vector("list", length = 5)
  for(i in 1:5){
    pvals[i] = as.numeric(t.test(songs[1,8:17], songs[i+1,8:17])[3]) #populating list
  }
min(as.numeric(pvals))
distinct(as.numeric(pvals))
```





